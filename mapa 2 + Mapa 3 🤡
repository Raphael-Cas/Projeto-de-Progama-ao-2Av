#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <windows.h>
#include <time.h>

#define TAM1 20
#define TAM2 40
#define VIDAS_INICIAIS 3

int mapaAtual = 1;
char player_tile_underneath = '.'; // Adiciona uma variável para o tile que o jogador está ocupando

// Limpa a tela
void limparTela() {
    system("cls");
}

// Desenha o mapa
void desenharMapa(char **mapa, int tam, int vidas, int temChave) {
    limparTela();
    for (int i = 0; i < tam; i++) {
        for (int j = 0; j < tam; j++) {
            printf("%c ", mapa[i][j]);
        }
        printf("\n");
    }
    printf("\nUse W A S D para mover, Q para sair. Pressione 'I' para interagir.\n");
    printf("Chave: %s | Vidas: %d\n", temChave ? "SIM" : "NAO", vidas);
}

// Cria um mapa dinâmico
char **criarMapa(int tam) {
    char **mapa = (char **)malloc(tam * sizeof(char *));
    for (int i = 0; i < tam; i++) {
        mapa[i] = (char *)malloc(tam * sizeof(char));
    }
    return mapa;
}

// Libera memória do mapa
void liberarMapa(char **mapa, int tam) {
    for (int i = 0; i < tam; i++) {
        free(mapa[i]);
    }
    free(mapa);
}

// Inicializa o mapa com tamanho e elementos
void inicializarMapa(char **mapa, int tam, int *px, int *py, int *vx, int *vy) {
    for (int i = 0; i < tam; i++)
        for (int j = 0; j < tam; j++)
            mapa[i][j] = '.';

    // Bordas
    for (int i = 0; i < tam; i++) {
        mapa[0][i] = '*';
        mapa[tam - 1][i] = '*';
        mapa[i][0] = '*';
        mapa[i][tam - 1] = '*';
    }

    srand(time(NULL));
    int num_paredes = (tam == TAM1) ? 40 : 150;

    // Posições iniciais do jogador e vilão (definidas aqui para garantir que não serão espinhos)
    *px = 1;
    *py = 1;
    *vx = tam - 2;
    *vy = tam - 2;

    // Objetos fixos (definidos antes dos espinhos para garantir que não serão sobrescritos)
    if (tam == TAM1) {
        mapa[10][10] = '@'; // Chave
        mapa[15][15] = 'D'; // Porta
        mapa[5][5] = '>';   // Teleporte
        mapa[10][5] = '<';  // Teleporte volta
    } else { // TAM2 (Sua "Fase 3")
        mapa[20][20] = '@'; // Chave
        mapa[35][35] = 'D'; // Porta
        mapa[10][10] = '>'; // Teleporte 1
        mapa[30][5] = '<';  // Teleporte 2
        mapa[5][tam / 2] = 'O'; // Novo botão 'O' na Fase 3, centralizado na parte superior
    }

    // Espinhos (garantindo que não cubram posições importantes)
    int paredes = 0;
    while (paredes < num_paredes) {
        int x = rand() % (tam - 2) + 1;
        int y = rand() % (tam - 2) + 1;
        
        // Evita gerar espinhos nas posições fixas de objetos e posições iniciais de player/vilão
        // Verifica se a posição (x,y) não é uma das posições de objetos fixos, jogador ou vilão
        if (mapa[y][x] == '.' && !(x == *px && y == *py) && !(x == *vx && y == *vy) ) {
            // Verifica também as posições dos objetos fixos que acabamos de colocar
            int is_fixed_object_pos = 0;
            if (tam == TAM1) {
                if ((x == 10 && y == 10) || (x == 15 && y == 15) || (x == 5 && y == 5) || (x == 10 && y == 5)) is_fixed_object_pos = 1;
            } else { // TAM2
                // Note: tam / 2 para o botão 'O' é a coluna, y é a linha (mapa[y][x])
                if ((x == 20 && y == 20) || (x == 35 && y == 35) || (x == 10 && y == 10) || (x == 30 && y == 5) || (x == tam / 2 && y == 5)) is_fixed_object_pos = 1;
            }

            if (!is_fixed_object_pos) {
                mapa[y][x] = '#';
                paredes++;
            }
        }
    }
}

// Movimento do vilão
void moverInimigo(char **mapa, int tam, int *vx, int *vy, int px, int py) {
    int dx = (px > *vx) ? 1 : (px < *vx) ? -1 : 0;
    int dy = (py > *vy) ? 1 : (py < *vy) ? -1 : 0;

    int nx = *vx + dx;
    int ny = *vy + dy;

    // Salva o caractere na posição antiga do vilão para restaurar depois
    char char_on_old_enemy_pos = mapa[*vy][*vx];

    // O vilão não deve mover para '*' (paredes), '#' (espinhos), 'D' (porta).
    // Ele pode passar por '@' (chave), '>' ou '<' (teleportes) e 'O' (botão).
    if (nx >= 0 && nx < tam && ny >= 0 && ny < tam &&
        mapa[ny][nx] != '*' && mapa[ny][nx] != '#' && mapa[ny][nx] != 'D') {
        
        // Se o vilão não está na mesma posição que o jogador, move
        if (nx != px || ny != py) {
            // Limpa a posição antiga do vilão, restaurando o caracter original
            if (char_on_old_enemy_pos == 'V') { // Se o vilão estava na sua própria posição normal
                mapa[*vy][*vx] = '.'; // Assume que o chão é '.'
            } else { // Restaura o item que estava debaixo do vilão
                mapa[*vy][*vx] = char_on_old_enemy_pos;
            }

            *vx = nx;
            *vy = ny;
            mapa[*vy][*vx] = 'V'; // Coloca o vilão na nova posição
        }
    }
}

// Nova função: transformar espinhos em paredes
void transformarEspinhosEmParedes(char **mapa, int tam) {
    for (int i = 0; i < tam; i++) {
        for (int j = 0; j < tam; j++) {
            if (mapa[i][j] == '#') {
                mapa[i][j] = '*'; // Transforma espinho em parede
            }
        }
    }
    printf("Todos os espinhos foram transformados em paredes!\n");
    Sleep(1500);
}


// Função principal do jogo
void jogar() {
    int tam = TAM1;
    char **mapa = criarMapa(tam);
    int px, py, vx, vy;
    int temChave = 0;
    int vidas = VIDAS_INICIAIS;
    char tecla;

    // Inicializa e posiciona o jogador e vilão no mapa inicial
    inicializarMapa(mapa, tam, &px, &py, &vx, &vy);
    player_tile_underneath = mapa[py][px]; // Inicializa o tile debaixo do jogador
    mapa[py][px] = '&'; // Coloca o jogador na posição inicial
    mapa[vy][vx] = 'V'; // Coloca o vilão na posição inicial

    while (1) {
        desenharMapa(mapa, tam, vidas, temChave);

        // Colisão com vilão (checado após o desenho para dar um frame de atraso visual)
        if (px == vx && py == vy) {
            vidas--;
            if (vidas <= 0) {
                printf("Você foi pego pelo inimigo! Game Over.\n");
                Sleep(2000);
                break;
            } else {
                printf("Você foi pego! Reiniciando posição...\n");
                Sleep(1000);
                
                // Reinicia o mapa completamente para evitar bugs de estado do mapa
                liberarMapa(mapa, tam);
                mapa = criarMapa(tam);
                inicializarMapa(mapa, tam, &px, &py, &vx, &vy); 
                player_tile_underneath = mapa[py][px]; // Reinicia o tile debaixo do jogador
                mapa[py][px] = '&'; // Coloca o jogador no novo mapa
                mapa[vy][vx] = 'V'; // Coloca o vilão no novo mapa
                temChave = 0; // Se colidir e reiniciar, perde a chave atual
                continue;
            }
        }

        tecla = _getch();
        if (tecla == 'q' || tecla == 'Q') break;

        // --- NOVA LÓGICA PARA INTERAGIR COM O BOTÃO 'O' ---
        if ((tecla == 'i' || tecla == 'I') && mapaAtual == 2 && player_tile_underneath == 'O') {
            transformarEspinhosEmParedes(mapa, tam);
            // Após a interação, o botão 'O' deve permanecer.
            // O jogador continua na mesma posição sobre o botão.
            // Não precisa mover o jogador, apenas redesenhar o mapa com as mudanças.
            // O vilão ainda precisa se mover.
            moverInimigo(mapa, tam, &vx, &vy, px, py);
            Sleep(100);
            continue; // Pula o resto do loop de movimento e redesenha
        }
        // --- FIM DA NOVA LÓGICA ---


        int old_px = px; // Armazena a posição antiga do jogador
        int old_py = py;

        int nx = px, ny = py;
        if (tecla == 'w' || tecla == 'W') ny--;
        if (tecla == 's' || tecla == 'S') ny++;
        if (tecla == 'a' || tecla == 'A') nx--;
        if (tecla == 'd' || tecla == 'D') nx++;

        // Checagem de movimento para paredes e vilão (antes de mover)
        // O jogador não pode mover para '*' (paredes) ou 'V' (vilão)
        if (mapa[ny][nx] != '*' && mapa[ny][nx] != 'V') { 
            // Restaura o tile que estava debaixo do jogador na posição antiga
            // Usa player_tile_underneath para restaurar o que estava na casa ANTES de o jogador pisar nela.
            mapa[old_py][old_px] = player_tile_underneath;

            px = nx;
            py = ny;
            // Salva o novo tile que o jogador está prestes a ocupar (o tile que está na nova posição)
            player_tile_underneath = mapa[py][px];
        }

        // Pisou em espinhos
        // Esta lógica deve ser revisada: se o jogador pisa em um espinho, ele perde vida e volta para (1,1).
        // Mas o espinho deve permanecer, certo?
        if (mapa[py][px] == '#') {
            vidas--;
            printf("Você pisou em espinhos! Vidas restantes: %d\n", vidas);
            Sleep(1000);
            if (vidas <= 0) {
                printf("Game Over!\n");
                Sleep(2000);
                break;
            }
            // Não limpa o espinho, apenas move o jogador de volta
            // A posição antiga (onde estava o espinho) deve continuar sendo um espinho
            px = 1; py = 1; // Volta para a posição inicial
            player_tile_underneath = mapa[py][px]; // Atualiza o tile debaixo do jogador
        }

        // Pega chave
        if (mapa[py][px] == '@') {
            temChave = 1;
            mapa[py][px] = '.'; // Remove a chave do mapa
            player_tile_underneath = '.'; // O tile debaixo agora é chão
            printf("Você pegou a chave!\n");
            Sleep(1000);
        }

        // Teleporte
        if (mapa[py][px] == '>') {
            printf("Teleportado!\n");
            Sleep(1000);
            // Restaura o teleporte na posição antiga antes de mover o jogador
            // Note: player_tile_underneath já foi usado para restaurar old_px, old_py
            // Agora, a nova posição do jogador (px,py) é atualizada
            if (tam == TAM1) {
                px = 10; py = 5;
            } else { // Se tam == TAM2
                px = 30; py = 5;
            }
            player_tile_underneath = mapa[py][px]; // Salva o tile no destino do teleporte
        }
        if (mapa[py][px] == '<') {
            printf("Teleportado de volta!\n");
            Sleep(1000);
            // Restaura o teleporte na posição antiga antes de mover o jogador
            mapa[old_py][old_px] = '<'; 

            if (tam == TAM1) {
                px = 5; py = 5;
            } else { // Se tam == TAM2
                px = 10; py = 10;
            }
            player_tile_underneath = mapa[py][px]; // Salva o tile no destino do teleporte
        }

        // Porta
        if (mapa[py][px] == 'D') {
            if (temChave && mapaAtual == 1) {
                printf("Você abriu a porta para o próximo mapa!\n");
                Sleep(1500);
                liberarMapa(mapa, tam);
                tam = TAM2; // Muda para a Fase 3
                mapa = criarMapa(tam);
                mapaAtual = 2; // Indica que está na Fase 3
                inicializarMapa(mapa, tam, &px, &py, &vx, &vy);
                player_tile_underneath = mapa[py][px]; // Reinicia o tile debaixo do jogador
                mapa[py][px] = '&'; // Coloca o jogador no novo mapa
                mapa[vy][vx] = 'V'; // Coloca o vilão no novo mapa
                temChave = 0; // Reinicia a chave para a próxima fase
                continue;
            } else if (mapaAtual == 2 && temChave) { // Agora a Fase 3 também requer chave
                printf("Parabéns! Você venceu o jogo!\n");
                Sleep(2000);
                break;
            } else {
                printf("Você precisa da chave.\n");
                Sleep(1000);
            }
        }

        // Coloca o jogador na sua nova posição
        mapa[py][px] = '&'; 

        // Movimento do vilão
        moverInimigo(mapa, tam, &vx, &vy, px, py);
        Sleep(100);
    }

    liberarMapa(mapa, tam);
}

// Tela de créditos
void creditos() {
    limparTela();
    printf("=== Créditos ===\n");
    printf("Desenvolvedores: Andre Bispo e Raphael Castro\n");
    printf("Agradecimentos: Gepeto, GitHub Copilot e ChatGPT\n");
    printf("\nPressione qualquer tecla para voltar ao menu...\n");
    _getch();
}

// Menu principal
int main() {
    int opcao;
    while (1) {
        limparTela();
        printf("=== Dungeon Crawler ===\n");
        printf("1. Jogar\n");
        printf("2. Créditos\n");
        printf("3. Sair\n");
        printf("Escolha uma opção: ");
        scanf("%d", &opcao);
        fflush(stdin);
        switch (opcao) {
            case 1: 
                mapaAtual = 1; // Garante que o jogo sempre comece na Fase 1
                jogar(); 
                break;
            case 2: creditos(); break;
            case 3: return 0;
            default:
                printf("Opção inválida.\n");
                Sleep(1000);
        }
    }
}
